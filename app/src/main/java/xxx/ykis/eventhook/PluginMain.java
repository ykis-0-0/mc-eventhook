/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package xxx.ykis.eventhook;

import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.io.IOException;

import org.bukkit.configuration.file.YamlConfiguration;

import org.bukkit.plugin.EventExecutor;

import org.bukkit.event.EventPriority;
import org.bukkit.event.command.UnknownCommandEvent;

import org.bukkit.plugin.java.annotation.plugin.*;
import org.bukkit.plugin.java.annotation.plugin.author.Author;
import org.bukkit.plugin.PluginLoadOrder;

@Plugin(name = "EventHook", version = "0.0-alpha")
@ApiVersion(ApiVersion.Target.v1_16)
@Author(value = "ykis-0-0")
@LogPrefix(value = "EventHook(Test)")
@LoadOrder(PluginLoadOrder.STARTUP)
public class PluginMain extends JavaPlugin {

  private boolean checkConfSchema() {
    YamlConfiguration configTemplate = YamlConfiguration.loadConfiguration(this.getTextResource("config.yml"));
    boolean permissible = true;
    boolean needSupplyDrop = false;

    int epochUsed = configTemplate.getInt("schema.epoch");
    if(epochUsed != this.getConfig().getInt("schema.epoch")){
      this.getLogger().warning("The existing config.yml is from another epoch, copying the new template.");
      permissible = false;
      needSupplyDrop = true;
    }

    int revisionUsed = configTemplate.getInt("schema.revision");
    if(revisionUsed != this.getConfig().getInt("schema.revision")){
      this.getLogger().warning("A newer revision of config.yml exists, copy a new template.");
      needSupplyDrop = true; // revision change isn't blocking
    }

    if(needSupplyDrop) {
      try {
        configTemplate.save(new File(this.getDataFolder(), "config.yml.newtemplate"));
        this.getLogger().info("New template saved as config.yml.newtemplate");
      } catch(IOException e) {
        e.printStackTrace();
        this.getLogger().severe("Could not save new configuration template");
      }
    }

    return permissible;
  }

  @Override
  public void onEnable() {
    this.getLogger().info("Enabled!");

    // In case for first launch
    this.getDataFolder().mkdir();
    this.saveDefaultConfig();
    this.getConfig().options().copyDefaults(false);

    // If the config.yml schema isn't compatible
    if(!this.checkConfSchema()) {
      this.getLogger().warning("Disabling myself, see you next time~");
      this.setEnabled(false);
      return;
    }

    Class<UnknownCommandEvent> evt = org.bukkit.event.command.UnknownCommandEvent.class;
    PsuedoListener listener = new PsuedoListener();
    EventPriority priority = EventPriority.MONITOR;
    EventExecutor executor = new CustomExecutor(this.getLogger(), priority);

    this.getServer().getPluginManager().registerEvent(evt, listener, priority, executor, this);
  }

  @Override
  public void onDisable() {
    this.getLogger().info("Disabled!");
  }
}
