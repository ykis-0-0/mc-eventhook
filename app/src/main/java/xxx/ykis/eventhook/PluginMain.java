/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package xxx.ykis.eventhook;

import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.io.IOException;

import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.configuration.ConfigurationSection;

import java.util.List;
import java.util.ArrayList;

import org.bukkit.event.Event;
import org.bukkit.event.EventPriority;

import org.bukkit.plugin.java.annotation.plugin.*;
import org.bukkit.plugin.java.annotation.plugin.author.Author;
import org.bukkit.plugin.PluginLoadOrder;

@Plugin(name = "EventHook", version = "0.0-alpha")
@ApiVersion(ApiVersion.Target.v1_16)
@Author(value = "ykis-0-0")
@LogPrefix(value = "EventHook(Test)")
@LoadOrder(PluginLoadOrder.STARTUP)
public class PluginMain extends JavaPlugin {

  private boolean checkConfSchema() {
    YamlConfiguration configTemplate = YamlConfiguration.loadConfiguration(this.getTextResource("defaults.yml"));
    boolean permissible = true;
    boolean needSupplyDrop = false;

    int epochUsed = configTemplate.getInt("schema.epoch");
    if(epochUsed != this.getConfig().getInt("schema.epoch")){
      this.getLogger().warning("The existing config.yml is from another epoch, copying the new template.");
      permissible = false;
      needSupplyDrop = true;
    }

    int revisionUsed = configTemplate.getInt("schema.revision");
    if(revisionUsed != this.getConfig().getInt("schema.revision")){
      this.getLogger().warning("A newer revision of config.yml exists, copy a new template.");
      needSupplyDrop = true; // revision change isn't blocking
    }

    if(needSupplyDrop) {
      try {
        configTemplate.save(new File(this.getDataFolder(), "config.yml.newtemplate"));
        this.getLogger().info("New template saved as config.yml.newtemplate");
      } catch(IOException e) {
        e.printStackTrace();
        this.getLogger().severe("Could not save new configuration template");
      }
    }

    return permissible;
  }

  private Athlete[] gatherAthletes() {
    if(!this.getConfig().isConfigurationSection("events")) {
      this.getLogger().severe("In config.yml[events]: Type mismatch, Map expected");
    }

    ConfigurationSection eventSection = this.getConfig().getConfigurationSection("events");
    ArrayList<Athlete> runners = new ArrayList<>();

    for(String atheleteId : eventSection.getKeys(false)) {
      ConfigurationSection data = eventSection.getConfigurationSection(atheleteId);

      final String eventFQCN = data.getString("event.class");
      final String priorityName = data.getString("event.priority");

      //#region Event Classification
      if(eventFQCN == null) {
        String message = "In config.yml[events.%s]: Target Event not specified";
        message = String.format(message, atheleteId);
        this.getLogger().severe(message);
        this.getLogger().warning("Entry Skipped");
        continue;
      }

      Class<? extends Event> eventClass = null;
      {
        String message = null;
        try {
          final Class<?> classInput = Class.forName(eventFQCN);
          eventClass = classInput.asSubclass(Event.class);
        } catch (ClassNotFoundException e) {
          message = String.format("In config.yml[events.%s]: Class not found: [%s]", atheleteId, eventFQCN);
        } catch (ClassCastException e) {
          message = String.format("In config.yml[events.%s]: Class [%s] is not (subclass of) [%s]",atheleteId, eventFQCN, Event.class.getName());
        } finally {
          if(message != null) {
            this.getLogger().severe(message);
            this.getLogger().warning("Entry skipped");
            continue;
          }
        }
      }

      if(eventClass == null) {
        String message = "In config.yml[events.%s]: Unable to retrieve class object: [%s]";
        this.getLogger().severe(String.format(message, atheleteId, eventFQCN));
        continue;
      }


      if(priorityName == null) {
        String message = "In config.yml[events.%s]: Runner Priority not specified";
        message = String.format(message, atheleteId);
        this.getLogger().severe(message);
        this.getLogger().warning("Entry Skipped");
        continue;
      }

      final EventPriority priority;
      try {
        priority = EventPriority.valueOf(priorityName);
      } catch (IllegalArgumentException e) {
        this.getLogger().severe(String.format("In config.yml[events.%s]: [%s] is not a valid EventPriority", atheleteId, priorityName));
        this.getLogger().warning("Entry Skipped");
        continue;
      }
      //#endregion

      final String execPath = data.getString("run.exec");
      final String workDirPath = data.getString("run.workdir");
      final boolean announce = data.getBoolean("run.announce", false);
      final List<String> args = data.getStringList("run.args");

      //#region Task Classification
      if(execPath == null) {
        String message = "In config.yml[events.%s]: Executable not specified";
        message = String.format(message, atheleteId);
        this.getLogger().severe(message);
        this.getLogger().warning("Entry Skipped");
        continue;
      }

      File workDir = workDirPath == null ? null : new File(workDirPath);
      if(workDir != null && !workDir.isDirectory()) {
        String message = "In config.yml[events.%s]: Working Directory [%s] specified but not a valid directory";
        message = String.format(message, atheleteId, workDir);
        this.getLogger().severe(message);
        this.getLogger().warning("Ignoring this line");
        workDir = null;
      }
      //#endregion

      runners.add(new Athlete(this, eventClass, priority, execPath, workDir, announce, args));
    }

    return runners.toArray(new Athlete[0]);
  }

  @Override
  public void onEnable() {
    this.getLogger().info("Enabled!");

    // In case for first launch
    this.getDataFolder().mkdir();
    this.saveDefaultConfig();
    this.getConfig().options().copyDefaults(false);

    // If the config.yml schema isn't compatible
    if(!this.checkConfSchema()) {
      this.getLogger().warning("Disabling myself, see you next time~");
      this.setEnabled(false);
      return;
    }

    Athlete[] runners = this.gatherAthletes();

    for(Athlete athelete : runners) {
      athelete.onMyMark();
    }
    this.getLogger().info(String.format("%d runners parsed successfully.", runners.length));
  }

  @Override
  public void onDisable() {
    this.getLogger().info("Disabled!");
  }
}
